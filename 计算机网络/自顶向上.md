[TOC]

# 章二 应用层

## 2.1 应用层协议原理

### 2.1.1网络应用程序体系结构

- CS架构  客户-服务器体系结构（client-server architecture）
- P2P架构  P2P 体系结构（P2P architecture）

### 2.1.2 进程通信

我们关注运行在不同端系统（可能具有不同的操作系统）上的进程间的通信：

在两个不同端系统上的进程，通过跨越计算机网络交换报文（message） 而相互通信。
发送进程生成并向网络中发送报文；接收进程接收这些报文并可能通过回送报文进行响应。

#### 2.1.2.1 客户和服务器进程

程序由成对的进程组成：发起通行的进程被标记为客户，在会话开始时等待联系的进程是服务器

#### 2.1.2.2 进程与计算机网络之间的接口

进程通过一个称为套接字（socket） 的软件接口向网络发送报文和从网络接收报文。(类比为房子的门)

套接字是同一台主机内应用层与运输层之间的接口。

由于该套接字是建立网络应用程序的可编程接口，因此套接字也称为应用程序和网络之间的应用程序编程接口（Application Programming Interface, API） 

应用程序开发者可以控制套接字在应用层端的一切，但是对该套接字的运输层端几乎没有
控制权。

应用程序开发者对于运输层的控制仅限于：①选择运输层协议；②也许能设定几个运输层参数，如最大缓存和最大报文段长度等。一旦应用程序开发者选择了一个运输层协议（如果可供选择的话），则应用程序就建立在由该协议提供的运输层服务之上。

#### 2.1.2.3 进程寻址

为了向特定目的地发送邮政邮件，目的地需要有一个地址。类似地，在一台主机上运行的进程为了向在另一台主机上运行的进程发送分组，接收进程需要有一个地址。

为了标识该接收进程，需要定义两种信息：①主机的地址；②在目的主机中指定接收进程的标
识符。

主机由其IP地址(IP address)标识 

发送进程还必须指定运行在接收主机上的接收进程(更具体地说，接收套接字)。目的地端口号(port number)用于这个目的

### 2.1.3 可供应用程序使用的运输服务

很多网络提供了不止一种运输层协议。当开发一个应用时，必须选择一种可用的运输层协议。

#### 2.1.3.1 可靠数据传输

分组在计算机网络中可能丢失

- 可靠数据传输(reliable data transfer) 
- 容忍丢失的应用(loss-tolerant application)

#### 2.1.3.2 吞吐量

- 带宽敏感的应用（bandwidth-sensitive application） 
- 弹性应用（elastic application）

#### 2.1.3.3 定时

#### 2.1.3.4 安全性

### 2.1.4 因特网提供的运输服务

#### 2.1.4.1 TCP 

TCP服务模型包括面向连接服务和可靠数据传输服务。

- 面向连接的服务:
> 在应用层数据报文开始流动之前，TCP让客户和服务器互相交换运输层控制信息。

    这个所谓的握手过程提醒客户和服务器，让它们为大量分组的到来做好准备。
    
    在握手阶段后，一个TCP连接（TCP connection）就在两个进程的套接字之间建立了。
    
    这条连接是全双工的，即连接双方的进程可以在此连接上同时进行报文收发。
    
    当应用程序结束报文发送时，必须拆除该连接。

- 可靠数据传输服务
> 进程能够依靠TCP,无差错、按适当顺序交付所有发送的数据。
>
> 当应用程序的一端将字节流传进套接字时，它能够依靠TCP将相同的字节流交付给接收方的套接字，而没有字节的丢失和冗余。

- 拥塞控制机制

> 发送方和接收方之间的网络出现拥塞时，TCP的拥塞控制机制会抑制发送进程

- 无加密机制

> TCP的加强版本，称为安全套接字层（Secure Sockets Layer, SSL） 
>
> 用SSL加强后的TCP不仅能够做传统的TCP所能做的一切，而且提供了关键的进程到进程的安全性服务，包括加密、数据完整性和端点鉴别。我们强调SSL不是与TCP和UDP在相同层次上的第三种因特网运输协议，而是一种对TCP的加强，这种强化是在应用层上实现的
>
> SSL有它自己的套接字API,这类似于传统的TCP套接字APIO当一个应用使用SSL时，发送进程向SSL套接字传递明文数据；在发送主机中的SSL则加密该数据并将加密的数据传递给TCP套接字。
>
> 加密的数据经因特网传送到接收进程中的TCP套接字。
>
> 该接收套接字将加密数据传递给SSL,由其进行解密。
>
> 最后，SSL通过它的SSL套接字将明文数据传递给接收进程。

#### 2.1.4.2 UDP服务

UDP是一种不提供不必要服务的轻量级运输协议，它仅提供最小服务。

UDP是无连接的，因此在两个进程通信前没有握手过程。

UDP协议提供一种不可靠数据传送服务，也就是说，当进程将一个报文发送进UDP套接字时，UDP协议并不保证该报文将到达接收进程。

不仅如此，到达接收进程的报文也可能是乱序到达的。

UDP没有包括拥塞控制机制，所以UDP的发送端可以用它选定的任何速率向其下层（网络层）注入数据。（然而，值得注意的是实际端到端吞吐量可能小于该速率，这可能是因为中间链路的带宽受限或因为拥塞而造成的。）

#### 2.1.4.3 因特网运输协议所不提供的服务

因特网通常能够为时间敏感应用提供满意的服务，但它不能提供任何定时或带宽保证。

### 2.1.5 应用层协议

应用层协议（application-layer protocol）定义了运行在不同端系统上的应用程序进程如何相互传递报文。特别是应用层协议定义了 :

- 交换的报文类型，例如请求报文和响应报文。
- 各种报文类型的语法，如报文中的各个字段及这些字段是如何描述的。
- 字段的语义，即这些字段中的信息的含义。
- 确定一个进程何时以及如何发送报文，对报文进行响应的规则。

有些应用层协议是由RFC文档定义的，因此它们位于公共域中。还有很多别的应用层协议是专用的，有意不为公共域使用。

区分网络应用和应用层协议是很重要的。应用层协议只是网络应用的一部分

> Web是一种客户-服务器应用，包括文档格式的标准（即HTML） 、Web浏览器（如Firefox和Microsoft Internet Explorer）、Web服务器（如Apache、Microsoft服务器程序），以及一个应用层协议。
>
> Web的应用层协议是HTTP,它定义了在浏览器和Web服务器之间传输的报文格式和序列。因此，HTTP只是Web应用的一个部分（尽管是重要部分）。

## 2.2 Web 和 HTTP

### 2.2.1 HTTP 概况

Web的应用层协议是超文本传输协议（HyperText Transfer Protocol, HTTP） ,它是Web的核心，在［RFC 1945］ 和［RFC 2616］ 中进行了定义。HTTP由两个程序实现：一个客户程序和一个服务器程序。客户程序和服务器程序运行在不同的端系统中，通过交换HTTP报文进行会话。HTTP定义了这些报文的结构以及客户和服务器进行报文交换的方式。

![image-20220202161833662](C:\Users\02\AppData\Roaming\Typora\typora-user-images\image-20220202161833662.png)

HTTP使用TCP作为它的支撑运输协议(而不是在UDP上运行)。HTTP客户首先发起一个与服务器的TCP连接。一旦连接建立，该浏览器和服务器进程就可以通过套接字接口访问TCP。

服务器向客户发送被请求的文件，而不存储任何关于该客户的状态信息。假如某个特定的客户在短短的几秒内两次请求同一个对象，服务器并不会因为刚刚为该客户提供了该对象就不再做出反应，而是重新发送该对象，就像服务器已经完全忘记不久之前所做过的事一样。因为HTTP服务器并不保存关于客户的任何信息，所以我们说HTTP是一个**无状态协议(stateless protocol)。**

### 2.2.2 非持续连接和持续连接

每个请求/响应对是经一个单独的TCP连接发送，还是所有的请求及其响应经相同的TCP连接发送呢？

采用前一种方法，该应用程序被称为使用非持续连接(non-persistent connection)；
采用后一种方法，该应用程序被称为使用持续连接(persistent connection) 

HTTP在其默认方式下使用持续连接，HTTP客户和服务器也能配置成使用非持续连接。

#### 2.2.2.1 采用非持续连接的HTTP

往返时间（Round・Trip Time, RTF）:该时间是指一个短分组从客户到服务器然后再返回客户所花费的时间。

RTT包括分组传播时延、分组在中间路由器和交换机上的排队时延以及分组处理时延。

![](https://raw.githubusercontent.com/biepin7/CloudForImg/master/20220202220755.png)

客户向服务器发送一个小TCP报文段，服务器用一个小TCP报文段做出确认和响应,最后，客户向服务器返回确认。三次握手中前两个部分所耗费的时间占用了一个RTT。完成了三次握手的前两个部分后，客户结合三次握手的第三部分（确认）向该TCP连接发送一个HTTP请求报文。一旦该请求报文到达服务器，服务器就在该TCP连接上发送HTML文件。该HTTP请求/响应用去了另一个RTT。因此，粗略地讲，总的响应时间就是两个RTT加上服务器传输HTML文件的时间。

非持续连接有一些缺点。

- 第一，必须为每一个请求的对象建立和维护一个全新的连接。对于每个这样的连接，在客户和服务器中都要分配TCP的缓冲区和保持TCP变量,给Web服务器带来了严重的负担，因为一台Web服务器可能同时服务于数以百计不同的客户的请求。
- 第二，就像我们刚描述的那样，每一个对象经受两倍RTT的交付时延,即一个RTT用于创建TCP,另一个RTT用于请求和接收一个对象。

#### 2.2.2.2 采用持续连接的HTTP

### 2.2.3 HTTP报文格式

#### 2.2.3.1 HTTP请求报文

```
GET /somedir/page.html HTTP/1.1
Host: www.someschool.edu
Connection: close
User-agent: Mozilla/5•0
Accept-language: fr

```

第一行：请求行（request line）请求行有3个字段：方法字段（GET、POST、HEAD、PUT和DELETE）、URL字段和HTTP版本字段

第二行：首部行（header line）

todo : 未完，标准

#### 2.2.3.2 HTTP响应报文

### 2.2.4 用户与服务器的交互：cookie

cookie技术有4个组件：

- 在HTTP响应报文中的一个cookie首部
- 在HTTP请求报文中的一个cookie首部行
- 在用户端系统中保留有一个cookie文件，并由用户的浏览器进行管理
- 位于Web站点的一个后端数据库。

cookie可以在无状态的HTTP之上建立一个用户会话层

### 2.2.5 Web 缓存 Web cache / proxy server

Web缓存器有自己的磁盘存储空间,并在存储空间中保存最近请求过的对象的副本。

可以配置用户的浏览器，使得用户的所有HTTP请求首先指向Web缓存器。一旦某浏览器被配置，每个对某对象的浏览器请求首先被定向到该Web缓存器。

### 2.2.6 条件GET方法

尽管高速缓存能减少用户感受到的响应时间，但也引入了一个新的问题，即存放在缓
存器中的对象副本可能是陈旧的。换句话说，保存在服务器中的对象自该副本缓存在客户上以后可能已经被修改了。幸运的是，HTTP协议有一种机制，允许缓存器证实它的对象是最新的。

这种机制就是条件GET （ conditional GET） 方法。如果：

①请求报文使用GET方法；并且

②请求报文中包含一个“ If・Modified-Since： ”首部行。

那么，这个HTTP请求报文就是一个条件GET请求报文。

## 2.4 DNS：因特网的目录服务

### 2.4.1 DNS提供的服务
能进行主机名到IP地址转换的目录服务：域名系统（Domain Name System, DNS）

DNS是：
- 一个由分层的DNS服务器（DNS server） 实现的分布式数据库；
- 一个使得主机能够查询分布式数据库的**应用层协议**。

DNS 服务器通常是运行 BIND （ Berkeley Internet Name Domain） 软件［BIND 2012 ］ 的 UNIX机器。DNS协议运行在UDP之上，使用53号端口。

1） 同一台用户主机上运行着DNS应用的客户端。
2） 浏览器从上述URL中抽取主机名 www.someschool.edu ,并将这台主机名传给
DNS应用的客户端。
3） DNS客户向DNS服务器发送一个包含主机名的请求。
4） DNS客户最终会收到一份回答报文，其中含有对应于该主机名的IP地址。
5） 一旦浏览器接收到来自DNS的该IP地址，它能够向位于该IP地址80端口的
HTTP服务器进程发起一个TCP连接。

